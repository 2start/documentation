# About ShiftLeft Policies

Policies are used by ShiftLeft to identify how your application communicates with the outside world, which transformations exist on data, and which information flows should be considered security violations. Policies are also used as the basis for Security Profiles, which automate code analysis by summarizing the vulnerabilities and data leaks present in code.

ShiftLeft includes default Policies that specify the most common types of vulnerabilities. In addition, ShiftLeft users can [create custom Policies](custom-policy.md) to introduce additional knowledge about, and to exclude parts of a default Policy that does not apply to, your application.

Policies are written in the ShiftLeft [Policy Language](policy-language.md).

## Types of ShiftLeft Policies

There are two types of policies:
 - Library Policies
 - Application Policies

Library Policies are applied on a per-need basis, when ShiftLeft engine discovers that a particular library is used in the provided submission. Library Policies define generic information flow that is independent from a customer application.

Application Policies allow for defining application-specific security violations or transformations. ShiftLeft engine either selects a default Application Policy, depending on the language used, or picks a one that was requested by the user (either provided by ShiftLeft or by the customer).

## Policies and ShiftLeft Ocular

Policies are identified by the filename extension `.policy` and are stored together with Ocular in the directory

```
~/bin/ocular/policy
```

Users can simply add or modify the existing policy files to achieve desired security semantics.

When you [create and work with a CPG using ShiftLeft Ocular](../using-ocular/getting-started/create-cpg.md), Library and Application Policies are automatically loaded and assigned.

Policies are stored based on their namespace information. For example, a Policy for
a class from a Java's Standard Library, [`java.io.ObjectInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html), will be available at

```
~/bin/ocular/policy/dynamic/java/io/ObjectInputStream.policy
```


## Policies and ShiftLeft Inspect

Policies are located in the ShiftLeft repository.
Refer to [custom policy guide](custom-policy.md#custom-policies-for-shiftleft-inspect) to inform yourself how to manage Application Policies.

Using the [CLI](../using-inspect-protect/using-cli/cli-reference.md#sl-policy-commands), you can

* View or Upload a Policy.
* Manage default Policies for Application submissions.

Similarly as in the Ocular case, Policies are named in the repository based on the namespace information. For example, a Policy for
a class from a Java's Standard Library, [`java.io.ObjectInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html), will be available under name

```
java.io/ObjectInputStream
```

in ShiftLeft's repository.

## Security Profile for Runtime (SPR)

The SPR is generated by ShiftLeft Inspect for use by ShiftLeft Protect. It specifies the vulnerabilities that the ShiftLeft Protect Microagent monitors and protects from in runtime. 

### The Default ShiftLeft Policy

The default ShiftLeft Policy for contains directives that define and identify:

* Exposed methods, interface interactions and transformations.

* Information flows, particularly data leaks.

* Taint semantics. 

By default, Policies use a generic set of sensitive variable names, which directly affect the security results you see. To illustrate the default Policy, take a look at how deserialization vulnerabilities are identified. The following directive

```
// A policy for java.io.ObjectInputStream class

IO deserialization = METHOD -f "java.io.ObjectInputStream.readObject:java.lang.Object()" { INST "SINK" }
```

specifies that the instance parameter of the method `readObject` should be considered as a data sink of a deserializer, that is, the instance parameter is deserialized.

This directive determines that all parameters tagged with the Spring annotations `CookieValue`, `PathVariable`, and a few others are to be tagged as "attacker-controlled". 

```
// A generic policy for org.springframework.web.bind.annotation.* classes

TAG "DATA_TYPE" -v "attacker-controlled" METHOD -a r"org\.springframework\.web\.bind\.annotation\.(Request|Get|Post|Put|Delete|Patch)Mapping" PAR -a r"org\.springframework\.web\.bind\.annotation\.(CookieValue|PathVariable|RequestParam|RequestBody)"
```

And this directive specifies that flows of `attacker-controlled` data into `deserializers` are worth reporting

```
// An Application Policy describing execution vulnerabilities

CONCLUSION attacker-to-deserializer = FLOW DATA (attacker-controlled) -> IO (deserializer)
WHEN CONCLUSION attacker-to-deserializer => EMIT {
    title: "Attacker controlled data to deserialization",
    description: "Attacker controlled data is deserialized in this flow. ...",
    category: "a1-injection",
    score: "8.0"
}
```

In this directive, the Policy also allows data transformations and checks to be identified in order to report flows of data, for data that does not undergo validation. 

Refer to the ShiftLeft [Policy Language](policy-language.md) for additional information and examples.
