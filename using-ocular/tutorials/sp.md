# Using ShiftLeft Ocular with Security Profiles

This tutorial demonstrates how ShiftLeft Ocular tooling can be used to:

* Automatically scan programs for vulnerabilities.
* Customize the scanner's detection rules.
* Automatically scan and generate a report through non-interactive scripts.

## Prerequisite

Install ShiftLeft Ocular into your local directory `$shiftleft`. Refer to 
[Installing ShiftLeft Ocular](../installation.md) for more information.

## Running the Hello-ShiftLeft Demo Java Application

This tutorial is based on the demo Java application [Hello-ShiftLeft](https://github.com/ShiftLeftSecurity/HelloShiftLeft). 
Hello-ShiftLeft is a Spring-based Web application that contains
different sample vulnerabilities, including typical injection
vulnerabilities and leakages of sensitive information. 

Focusing on an object deserialization vulnerability in the `AdminController` 

```java
...
@Controller
public class AdminController {
...
@RequestMapping(value = "/admin/login", method = RequestMethod.POST)
public String doPostLogin(
  @CookieValue(value = "auth", defaultValue = "notset") String auth,
  @RequestBody String password, HttpServletResponse response,
  HttpServletRequest request) throws Exception {
...
if (!auth.equals("notset")) {
   if(isAdmin(auth)) {
     request.getSession().setAttribute("auth",auth);
     return succ;
   }
 }
 ...
}
...
private boolean isAdmin(String auth) {
try {
	ByteArrayInputStream bis = new ByteArrayInputStream(
  	Base64.getDecoder().decode(auth));
	ObjectInputStream objectInputStream = new ObjectInputStream(bis);
	Object authToken = objectInputStream.readObject();
  return ((AuthToken) authToken).isAdmin();
	} catch (Exception ex) {
   	System.out.println(" cookie cannot be deserialized: "
                      +ex.getMessage());
   	return false;
	}
}
...
```

In this code fragment, a cookie is received via HTTP and eventually
deserialized to create a Java object, an optimistic practice that can
often be exploited by attackers for arbitrary code execution. 

## Generating CPGs and Security Profiles

Generate a CPG for the `hello-shiftleft.jar`

```bash
cd $shiftleft
ocular> ./java2cpg.sh subjects/hello-shiftleft-0.0.1-SNAPSHOT.jar -o cpg.bin.zip
```

This command creates a file named `cpg.bin.zip` containing the CPG in a binary format.

The CPG can be automatically analyzed using the `cpg2sp` tool to determine potentially vulnerable flows and summarize them in a Security Profile

```bash
ocular> ./cpg2sp.sh --cpg ./cpg.bin.zip -o hello.sp --overlay
```

This command creates a file named `hello.sp` containing the Security Profile from the CPG in `cpg.bin.zip`. The Security Profile is generated by evaluating the Policy in `~/.shiftleft/policy/` against the CPG.

## Generating an Initial Scan Report

ShiftLeft Ocular lets you query, interactively and non-interactively, CPGs and Security Profiles. For example, the script in `scripts/report.sc`:

```scala
@main def exec(spFilename: String, outFilename: String) = {
  loadCpgWithOverlays("cpg.bin.zip", spFilename)
  cpg.finding.sortedByScore.l |> outFilename
}
```

This script loads the Security Profile at `spFilename`, and evaluates the expression `sp.findings.sortedByScore.l` to obtain a list of findings sorted by score. The list is piped to the file `outFilename` via the `|>` operator.

This script

```bash
ocular> ./ocular.sh --script scripts/report.sc --params spFilename=hello.sp,outFilename=report.txt
```

generates the text file `report.txt`, which contains all findings in a human-readable format. One of the findings is

```
Title: attacker-to-deserializer
Score: 8.0
Categories: [a1-injection]
Flow ids: [2963]
Description: Attacker controlled data is deserialized in this flow. This can lead to an ...
Flow 0:
IO Tags: Set(http) -> Set()
Data Tags: Set(DATA_TYPE: attacker-controlled, TRANSFORMER_TYPE: -base64encoded)
routes: Set(/admin/login)
trigger methods:
io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)

Primary flow:
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
| param     | type                        | method     | signature                                                                                                                                                                           |
|============================================================================================================================================================================================================================================|
| auth(1)   | java.lang.String            | doPostLogin| io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)|
| auth(1)   | java.lang.String            | isAdmin    | io.shiftleft.controller.AdminController.isAdmin:boolean(java.lang.String)                                                                                                           |
| param0(1) | java.lang.String            | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| return(-1)| byte[]                      | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| param0(1) | byte[]                      | <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| this(0)   | java.io.ByteArrayInputStream| <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| param0(1) | java.io.InputStream         | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
| this(0)   | java.io.ObjectInputStream   | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
```
This finding identifies a potential deserialization vulnerability triggerable via HTTP, an injection vulnerability with a score of 8.0. Findings are scored in order to allow for filtering. Findings also include a human-readable description that further characterizes the potential vulnerability, as well as the information flows associated with the vulnerability.

In this example, a single information flow is associated with the vulnerability. ShiftLeft Ocular identifies that the parameter `auth` of the method `doPostLogin` is attacker-controlled with high probability, since it is an HTTP request header. Tracking the flow of `auth`, the variable is passed into the method `isAdmin`, where it is Base64-decoded and used in the initialization of a `ByteArrayInputStream`. This input stream is itself used to initialize an `ObjectInputStream`. Lastly, the `readObject` method is invoked on the tainted input stream, resulting in the deserialization of attacker-controlled data. The flow description additionally provides HTTP input routes when possible (`/admin/login` in this case), and externally triggerable methods to invoke the vulnerable flow (`doPostLogin` in this example).

## Interactively Exploring and Filtering Security Profiles

Security Profiles are explored interactively with ShiftLeft Ocular using a domain specific language. ShiftLeft Ocular is started by

```
> sh ocular.sh                                                                                                                  
Compiling (synthetic)/ammonite/predef/interpBridge.sc
Commands:
helpMsg                         // prints this help dialog
status                          // prints the current status
loadCpg("path/to/file.[xml|gryo|bin.zip]") // loads cpg (format inferred from suffix)
loadSp("path/to/file.[sp]")                        // load sp

Ocular status:
No CPG currently loaded.
CPG can be loaded via a `loadCpg` command. See `help`.
Welcome to ShiftLeft Ocular
ocular>  
```

As demonstrated in the non-interactive script `report.sc`, load the Security Profile `hello.sp` by issuing the command

```scala
ocular> loadCpgWithOverlays("cpg.bin.zip", "hello.sp")
```

This command creates an object named `sp` that provides access to the Security Profile. ShiftLeft Ocular offers tab-completion to facilitate learning of the domain specific query language. For example, enter

```scala
cpg.finding.<TAB>
!=             category       equals         getClass       isInstanceOf   raw            scoreAtMost    spTestsFlows   |>
==             dedup          filter         hashCode       l              score          size           title
asInstanceOf   description    flatMap        ioFlows        map            scoreAtLeast   sortedByScore  toString
```

to obtain a list of possible operations that can be executed on findings. In particular, findings support the `scoreAtLeast` method, which allows findings to be filtered such that only findings scored above or equal to a threshold are returned. For example

```scala
ocular> cpg.finding.scoreAtLeast(8).l.size
```

returns only findings with a score of at least 8. Note that the query language is lazily evaluated, that is, `sp.findings.scoreAtLeast(8)` only yields in an expression, and it is only evaluated as it is converted to a list through the `l` directive (a shorthand for "toList").

All string properties support regular expressions. For example, obtain all findings related to serialization by

```scala
ocular> cpg.finding.title(".*serializatio.*").l
```

All lists support the functional combinators of the Scala language. Moreover, the functional combinators `filter`, `map`, and `flatMap` are provided directly for expression of the DSL. For example, instead of using the built-in method `scoreAtLeast`, the same effect can be achieved via a filter operation

```scala
ocular> cpg.finding.filterOnEnd(_.score >= 8).l.size
```

This allows more complex filtering rules to be expressed via lambdas. For example

```scala
ocular> cpg.finding.filterOnEnd(x =>  x.score >=8 && x.category == "a1-injection").l
```

returns only the findings with a score greater or equal to 8, where the finding's category is `a1-injection`.

## Customizing the DSL Using the "Extend My Library" Pattern

The domain specific language can be enhanced using the "Extend my Library" pattern. For example, a method named `whatICareAbout` is added to findings, which can subsequently be evaluated just like built-in language elements

```scala
import io.shiftleft.passes.findings.steps.Finding

class MyMethods(finding : Finding) {
    <b>def whatICareAbout = finding.filterOnEnd(x => x.score >= 8 && x.categories.contains("a1-injection"))</b>
}

implicit def conv(findings: Finding) = new MyMethods(findings)

@main def exec(spFilename: String, outFilename: String) = {
    loadCpgWithOverlays("cpg.bin.zip", spFilename)
    sp.findings.whatICareAbout.l |> outFilename
}
```
