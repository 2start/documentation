Original material https://github.com/ShiftLeftSecurity/documentation/blob/baba13cddda4d1940d16b29456edf5383b88887b/using-ocular/tutorials/sp.md

Look at definition in Terminology

Also need info on Security Profile for Runtime (SPR)

Link to General topic in Profiles and Policies

# Generating and Working with Security Profiles

Automatic Code Scanning through Security Profiles/ Security Profiles are dervied from Policies, and summarize the  vulnerabilities and data leaks present in the code. The Security Profile is a [layer](https://ocular.shiftleft.io/api/io/shiftleft/repl/cpgcreation/Overlays$.html) of the CPG. Unlike other default layers, the Security Profile must be intentially generated. Security Profiles can be explored and processed using the REPL and managed in a workspace.

SP = result of the default queries (= Policy)

This tutorial demonstrates how ShiftLeft Ocular tooling can be used to:

Automatically scan programs for vulnerabilities.
Customize the scanner's detection rules.
Automatically scan and generate a report through non-interactive scripts.
Prerequisite
Install ShiftLeft Ocular into your local directory $shiftleft. Refer to Installing ShiftLeft Ocular for more information.

Running the Hello-ShiftLeft Demo Java Application
This tutorial is based on the demo Java application Hello-ShiftLeft. Hello-ShiftLeft is a Spring-based Web application that contains different sample vulnerabilities, including typical injection vulnerabilities and leakages of sensitive information.

Focusing on an object deserialization vulnerability in the AdminController

...
@Controller
public class AdminController {
...
@RequestMapping(value = "/admin/login", method = RequestMethod.POST)
public String doPostLogin(
  @CookieValue(value = "auth", defaultValue = "notset") String auth,
  @RequestBody String password, HttpServletResponse response,
  HttpServletRequest request) throws Exception {
...
if (!auth.equals("notset")) {
   if(isAdmin(auth)) {
     request.getSession().setAttribute("auth",auth);
     return succ;
   }
 }
 ...
}
...
private boolean isAdmin(String auth) {
try {
	ByteArrayInputStream bis = new ByteArrayInputStream(
  	Base64.getDecoder().decode(auth));
	ObjectInputStream objectInputStream = new ObjectInputStream(bis);
	Object authToken = objectInputStream.readObject();
  return ((AuthToken) authToken).isAdmin();
	} catch (Exception ex) {
   	System.out.println(" cookie cannot be deserialized: "
                      +ex.getMessage());
   	return false;
	}
}
...
In this code fragment, a cookie is received via HTTP and eventually deserialized to create a Java object, an optimistic practice that can often be exploited by attackers for arbitrary code execution.

Generating CPGs and Security Profiles
Generate a CPG for the hello-shiftleft.jar

cd $shiftleft
./java2cpg.sh subjects/hello-shiftleft-0.0.1-SNAPSHOT.jar -o cpg.bin.zip
This command creates a file named cpg.bin.zip containing the CPG in a binary format.

The CPG can be automatically analyzed using the cpg2sp tool to determine potentially vulnerable flows and summarize them in a Security Profile

./cpg2sp.sh --cpg ./cpg.bin.zip -o hello.sp --overlay
This command creates a file named hello.sp containing the Security Profile from the CPG in cpg.bin.zip. The Security Profile is generated by evaluating the Policy in ~/.shiftleft/policy/ against the CPG.

## Generating a Security Profile

from the default queries (Policies) = Inspect but Inspect has a UI and works in the cloud

cpg.finding

Policy = derive default queries internally from Policy Language, those are then executed, and the results are put into the Security Profile

Possible to use Ocular with just default queries (Profiles), but the strength of Ocular is the ability to write their own custom queries to improve the quality of results

custom queries are created using either OCL or the Policy language.

### Writing Results to a File

ShiftLeft Ocular lets you query, interactively and non-interactively, CPGs and Security Profiles. For example, the script in scripts/report.sc:

@main def exec(spFilename: String, outFilename: String) = {
  loadCpgWithOverlays("cpg.bin.zip", spFilename)
  cpg.finding.sortedByScore.l |> outFilename
}
This script loads the Security Profile at spFilename, and evaluates the expression sp.findings.sortedByScore.l to obtain a list of findings sorted by score. The list is piped to the file outFilename via the |> operator.

This script

./ocular.sh --script scripts/report.sc --params spFilename=hello.sp,outFilename=report.txt
generates the text file report.txt, which contains all findings in a human-readable format. One of the findings is

Title: attacker-to-deserializer
Score: 8.0
Categories: [a1-injection]
Flow ids: [2963]
Description: Attacker controlled data is deserialized in this flow. This can lead to an ...
Flow 0:
IO Tags: Set(http) -> Set()
Data Tags: Set(DATA_TYPE: attacker-controlled, TRANSFORMER_TYPE: -base64encoded)
routes: Set(/admin/login)
trigger methods:
io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)

Primary flow:
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
| param     | type                        | method     | signature                                                                                                                                                                           |
|============================================================================================================================================================================================================================================|
| auth(1)   | java.lang.String            | doPostLogin| io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)|
| auth(1)   | java.lang.String            | isAdmin    | io.shiftleft.controller.AdminController.isAdmin:boolean(java.lang.String)                                                                                                           |
| param0(1) | java.lang.String            | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| return(-1)| byte[]                      | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| param0(1) | byte[]                      | <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| this(0)   | java.io.ByteArrayInputStream| <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| param0(1) | java.io.InputStream         | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
| this(0)   | java.io.ObjectInputStream   | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
This finding identifies a potential deserialization vulnerability triggerable via HTTP, an injection vulnerability with a score of 8.0. Findings are scored in order to allow for filtering. Findings also include a human-readable description that further characterizes the potential vulnerability, as well as the information flows associated with the vulnerability.

In this example, a single information flow is associated with the vulnerability. ShiftLeft Ocular identifies that the parameter auth of the method doPostLogin is attacker-controlled with high probability, since it is an HTTP request header. Tracking the flow of auth, the variable is passed into the method isAdmin, where it is Base64-decoded and used in the initialization of a ByteArrayInputStream. This input stream is itself used to initialize an ObjectInputStream. Lastly, the readObject method is invoked on the tainted input stream, resulting in the deserialization of attacker-controlled data. The flow description additionally provides HTTP input routes when possible (/admin/login in this case), and externally triggerable methods to invoke the vulnerable flow (doPostLogin in this example).

## Interactively Exploring and Filtering Security Profiles

All CPG findings listed in Security Profile. Filter to show subset of findings of interest.

Security Profiles are explored interactively with ShiftLeft Ocular using a domain specific language. ShiftLeft Ocular is started by

> sh ocular.sh                                                                                                                  
Compiling (synthetic)/ammonite/predef/interpBridge.sc
Commands:
helpMsg                         // prints this help dialog
status                          // prints the current status
loadCpg("path/to/file.[xml|gryo|bin.zip]") // loads cpg (format inferred from suffix)
loadSp("path/to/file.[sp]")                        // load sp

Ocular status:
No CPG currently loaded.
CPG can be loaded via a `loadCpg` command. See `help`.
Welcome to ShiftLeft Ocular
ocular>  
As demonstrated in the non-interactive script report.sc, load the Security Profile hello.sp by issuing the command

loadCpgWithOverlays("cpg.bin.zip", "hello.sp")
This command creates an object named sp that provides access to the Security Profile. ShiftLeft Ocular offers tab-completion to facilitate learning of the domain specific query language. For example, enter

cpg.finding.<TAB>
!=             category       equals         getClass       isInstanceOf   raw            scoreAtMost    spTestsFlows   |>
==             dedup          filter         hashCode       l              score          size           title
asInstanceOf   description    flatMap        ioFlows        map            scoreAtLeast   sortedByScore  toString
to obtain a list of possible operations that can be executed on findings. In particular, findings support the scoreAtLeast method, which allows findings to be filtered such that only findings scored above or equal to a threshold are returned. For example

cpg.finding.scoreAtLeast(8).l.size
returns only findings with a score of at least 8. Note that the query language is lazily evaluated, that is, sp.findings.scoreAtLeast(8) only yields in an expression, and it is only evaluated as it is converted to a list through the l directive (a shorthand for "toList").

All string properties support regular expressions. For example, obtain all findings related to serialization by

cpg.finding.title(".*serializatio.*").l
All lists support the functional combinators of the Scala language. Moreover, the functional combinators filter, map, and flatMap are provided directly for expression of the DSL. For example, instead of using the built-in method scoreAtLeast, the same effect can be achieved via a filter operation

cpg.finding.filterOnEnd(_.score >= 8).l.size
This allows more complex filtering rules to be expressed via lambdas. For example

cpg.finding.filterOnEnd(x =>  x.score >=8 && x.category == "a1-injection").l
returns only the findings with a score greater or equal to 8, where the finding's category is a1-injection.

Using a Policy to Scan for Data-Flow Vulnerabilities
The CPG query language can be used to formulate vulnerability patterns, and these queries can be used in a non-interactive script to automatically scan for vulnerability patterns. For data-flow related vulnerabilities, ShiftLeft Ocular provides a more concise mechanism, the Policy. A Policy defines methods that introduce data into the application, sensitive operations, and data-flow that should be reported. For example, in ShiftLeft's dynamic Policy, find the following lines

// [~/.shiftleft/policy/dynamic/java/io/ObjectInputStream.policy:]

IO deserializer = METHOD -f "java.io.ObjectInputStream.readObject:java.lang.Object()" { INST "SINK" }
This states that the instance parameter of the method readObject should be considered as a data sink of a deserializer, that is, the instance parameter is deserialized.

// ~/.shiftleft/policy/dynamic/org/springframework/exposed.policy:

TAG "DATA_TYPE" -v "attacker-controlled" METHOD -a r"org\.springframework\.web\.bind\.annotation\.(Request|Get|Post|Put|Delete|Patch)Mapping" PAR -a r"org\.springframework\.web\.bind\.annotation\.(CookieValue|PathVariable|RequestParam|RequestBody)"
This rule specifies that all parameters tagged with the Spring annotations CookieValue, PathVariable, and a few others are to be tagged as "attacker-controlled". Finally, specify that flows of attacker-controlled data into deserializers are worth reporting

// ~/.shiftleft/policy/static/execute.policy:

CONCLUSION attacker-to-deserializer = FLOW DATA (attacker-controlled) -> IO (deserializer)
WHEN CONCLUSION attacker-to-deserializer => EMIT {
    title: "Attacker controlled data to deserialization",
    description: "Attacker controlled data is deserialized in this flow. ...",
    category: "a1-injection",
    score: "8.0"
}
The Policy also allows data transformations and checks to be specified in order to report flows of data, for data that does not undergo validation. For more information, refer to the Policy Language article.

Extending the DSL Using the "Pimp My Library" Pattern
The domain specific language can be enhanced using the "Pimp my library pattern". For example, a method named whatICareAbout is added to findings, which can subsequently be evaluated just like built-in language elements

import io.shiftleft.passes.findings.steps.Finding

class MyMethods(finding : Finding) {
    <b>def whatICareAbout = finding.filterOnEnd(x => x.score >= 8 && x.categories.contains("a1-injection"))</b>
}

implicit def conv(findings: Finding) = new MyMethods(findings)

@main def exec(spFilename: String, outFilename: String) = {
    loadCpgWithOverlays("cpg.bin.zip", spFilename)
    sp.findings.whatICareAbout.l |> outFilename
}
© 2019 GitHub, Inc.
Terms
Privacy
Security
Status
Help
Contact GitHub
Pricing
API
Training
Blog
About


### Loading a CPG with an Additional Layer

You can load a single CPG, with additional layers that you have created, using the command

```scala
ocular> loadCpg(<name>, <overlayNames>)
```

and to load multiple CPGs with additional layers using the command  

```scala
ocular> loadCpgs(<names>), <overlayNames>)
```
where `<names>` a list of filenames of the applications whose CPGs you want to load, and `<overlayNames>` is the name of one or more additional layers you want to load, separted by commas. 
  
The order in which layers are loaded into the workspace is significant, since the layers depend on each other and reference lower layers. So you should load the base, semanticcpg and tagging layers first, which are automatically loaded with the CPG, and then load the SP.



## Viewing the Contents of Your Workspace

To view the contents of your workspace, use the command

```scala
ocular> workspace
```

Information on the application, its layers and whether the application CPG and layers are loaded into your workspace is displayed.

![Contents of Workspace](img/workspace.jpg)

You can get a list of the layers currently loaded into your workspace by using the command 

```scala
ocular> overlays
```


## Loading and Adding Layers
 
To load an additional layer that you created into your workspace, and add it to the active CPG, use

```scala
ocular> addOverlay(<names>)
```
  
where `<names>` is the name of one or more layers you want to load, separted by commas. 

And to load a layer into your workspace and add it to a specific CPG, use the command 

```scala
ocular> addOverlay(<baseCpg>, <names>)
```
where `<baseCpg>` is filename of the CPG to which you want to add the layer, and `<names>` is the name of one or more layers you want to load, separted by commas. 
